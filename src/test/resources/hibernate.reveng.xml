<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-reverse-engineering PUBLIC
    "-//Hibernate/Hibernate Reverse Engineering DTD 3.0//EN"
    "http://hibernate.org/dtd/hibernate-reverse-engineering-3.0.dtd" >
 
<hibernate-reverse-engineering>
    
    <!-- 
        Maps SQL type to Java type. In this case, SQL type TIMESTAMP WITH TIMEZONE will
        be mapped to java.time.OffsetDateTime in generated entity java class. By default,
        TIMESTAMP WITH TIMEZONE will be mapped to java.io.Serializable.
    -->
    <!-- jdbc-type must be in SQLType. see https://docs.oracle.com/javase/8/docs/api/java/sql/JDBCType.html -->
    <type-mapping>
        <sql-type jdbc-type="TIMESTAMP_WITH_TIMEZONE" hibernate-type="java.time.OffsetDateTime" />
    </type-mapping>
    
    <!-- These are case sensitive, somehow, to the database. See the generated entries in @Table -->
    <table schema="PUBLIC" catalog="DB1" name="USERS">
        <primary-key>

        </primary-key>
        
        <!-- These must also be case sensitive. See the generated entries in @Column -->
        <!-- Apparently, there are two optional fields, property="ID" and type="java type here" -->
        <!-- 
            The goal here is to generate equals() and hashcode() function, because by default, 
            these are not generated by Hibernate Tools. For each columns, add meta attribute use-in-equals
            to add that column to be used in equals and hashcode.
        -->
        <column name="ID">
            <meta attribute="use-in-equals">true</meta>
        </column>
        <!-- Adding other columns: -->
        <!--
        <column name="OTHERCOLUMN">
            <meta attribute="use-in-equals">true</meta>
        </column>
        -->
     
    </table>
</hibernate-reverse-engineering>